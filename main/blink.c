/* Blink Example

这个例子是点亮LCD屏的例子
*/
#include <stdio.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "driver/gpio.h"
#include "sdkconfig.h"
#include "driver/uart.h"
#include "driver/i2c.h"

#define WHITE 0xFFFF
#define BLACK 0x0000
#define BLUE 0x001F
#define BRED 0xF81F
#define GRED 0xFFE0
#define GBLUE 0x07FF
#define RED 0xF800
#define MAGENTA 0xF81F
#define GREEN 0x07E0
#define CYAN 0x7FFF
#define YELLOW 0xFFE0
#define BROWN 0XBC40
#define BRRED 0XFC07
#define GRAY 0X8430

/* -----------------------------------------------------------*/
#define SCL_PIN           GPIO_NUM_18
#define SCL_INIT_OUT()    gpio_set_direction(SCL_PIN, GPIO_MODE_OUTPUT)
#define SCL_H             gpio_set_level(SCL_PIN,1)
#define SCL_L             gpio_set_level(SCL_PIN,0)

#define SDA_PIN           GPIO_NUM_17
#define SDA_INIT_OUT()    gpio_set_direction(SDA_PIN, GPIO_MODE_OUTPUT)
#define SDA_INIT_INPUT()  gpio_set_direction(SDA_PIN, GPIO_MODE_INPUT)
#define SDA_H             gpio_set_level(SDA_PIN,1)
#define SDA_L             gpio_set_level(SDA_PIN,0)


void I2C_DELAY(void)
{
    // asm("NOP");
    // Delay_us(2);
    for (uint16_t i = 0;i < 100;i++);
}

void i2cGpioConfiguration(void)
{
    // RST_INIT_OUT();
    gpio_reset_pin(SCL_PIN);
    SCL_INIT_OUT();
    gpio_reset_pin(SDA_PIN);
    SDA_INIT_OUT();
    SCL_H;
    SDA_H;
    // softResetSensor();
}

void i2cStart(void)
{
    SDA_H;
    SCL_H;
    SDA_L;
    I2C_DELAY();
    SCL_L;
}

void i2cStop(void)
{
    SCL_L;
    SDA_L;
    SCL_H;
    I2C_DELAY();
    SDA_H;
}

void endI2c(void) // 需要低功耗，所以配置引脚
{
    SCL_L;
    SDA_L;
}

// 主机上传一个字节,并返回从机的应答状态
uint8_t i2cWriteByte(uint8_t data)
{
    uint8_t isAck = 0, mask;
    //上传8个bit
    for (mask = 0x80; mask != 0; mask >>= 1)
    {
        if ((data & mask) == 0)
            SDA_L;
        else
            SDA_H;
        I2C_DELAY();
        SCL_H;
        I2C_DELAY();
        SCL_L;
    }
    //捕获ack
    gpio_reset_pin(SDA_PIN);
    SDA_INIT_INPUT(); //主机释放数据线
    I2C_DELAY();
    SCL_H;
    I2C_DELAY();
    isAck = gpio_get_level(SDA_PIN);
    SCL_L;
    SDA_INIT_OUT();
    return !isAck;
}

//主机读取一个字节,可以选择应答或者不应答从机
uint8_t i2cReadByte(bool isAck)
{
    uint8_t dat = 0, mask;
    //接收8个bit
    SDA_INIT_INPUT();
    SCL_H;
    for (mask = 0x80; mask != 0; mask >>= 1)
    {
        I2C_DELAY();
        SCL_H;
        I2C_DELAY();
        if (gpio_get_level(SDA_PIN) == 0)
            dat &= ~mask;
        else
            dat |= mask;
        I2C_DELAY();
        SCL_L;
    }
    //决定是否ack
    SDA_INIT_OUT();
    if (isAck)
        SDA_L;
    else
        SDA_H;
    I2C_DELAY();
    SCL_H;
    I2C_DELAY();
    SCL_L;
    return dat;
}

// 判断设备是否空闲
bool isIdle(uint8_t deviceAddr)
{
    i2cStart();
    if (i2cWriteByte(deviceAddr)){
        return 1;
    }
    
    else
    {
        i2cStop();
        return 0;
    }
}

/* -----------------------------------------------------------*/

/* Can use project configuration menu (idf.py menuconfig) to choose the GPIO to blink,
or you can edit the following line and set a number here.
*/



uint8_t number0_18[] = {
0x00,0x7E,0x00,0x80,0xFF,0x01,0xC0,0xFF,0x03,0xE0,0xFF,0x07,0xF0,0xC3,0x0F,0xF0,
0x80,0x0F,0xF0,0x00,0x0F,0xF8,0x00,0x1F,0x78,0x00,0x1E,0x78,0x00,0x1E,0x78,0x00,
0x1E,0x78,0x00,0x1E,0x78,0x00,0x1E,0x78,0x00,0x1E,0x78,0x00,0x1E,0x78,0x00,0x1E,
0x78,0x00,0x1E,0x78,0x00,0x1E,0xF8,0x00,0x1F,0xF0,0x00,0x0F,0xF0,0x00,0x0F,0xF0,
0xC3,0x0F,0xE0,0xFF,0x07,0xE0,0xFF,0x03,0x80,0xFF,0x01,0x00,0x7E,0x00,/*"0",0*/
};

uint8_t number1_18[] = {
0x00,0x70,0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,0x7C,0x00,0x00,0x7F,0x00,0x80,
0x7F,0x00,0xE0,0x7B,0x00,0xE0,0x79,0x00,0x60,0x78,0x00,0x00,0x78,0x00,0x00,0x78,
0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,0x78,0x00,
0x00,0x78,0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,
0x78,0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,0x78,0x00,/*"1",0*/
}; // 24 * 26


uint8_t number2_18[] = {
0x00,0x7F,0x00,0xE0,0xFF,0x03,0xF0,0xFF,0x07,0xF8,0xFF,0x0F,0xF8,0xC0,0x0F,0x7C,
0x00,0x1F,0x3C,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,
0x0F,0x00,0x80,0x0F,0x00,0xC0,0x07,0x00,0xE0,0x03,0x00,0xF0,0x01,0x00,0xF8,0x00,
0x00,0x7E,0x00,0x00,0x3F,0x00,0xC0,0x0F,0x00,0xE0,0x07,0x00,0xF0,0x03,0x00,0xF0,
0x00,0x00,0x78,0x00,0x00,0xFC,0xFF,0x1F,0xFC,0xFF,0x1F,0xFC,0xFF,0x1F,/*"2",0*/
};

uint8_t number3_18[] = {
0x00,0x3F,0x00,0xC0,0xFF,0x00,0xE0,0xFF,0x03,0xF0,0xFF,0x03,0xF0,0xE1,0x07,0xF8,
0x80,0x07,0x78,0x80,0x07,0x00,0x80,0x07,0x00,0x80,0x03,0x00,0xE0,0x03,0x00,0xFC,
0x00,0x00,0xFC,0x00,0x00,0xFC,0x03,0x00,0x80,0x07,0x00,0x00,0x0F,0x00,0x00,0x1E,
0x00,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x1E,0x78,0x00,0x1E,0xF8,0x00,0x0F,0xF0,
0x81,0x0F,0xF0,0xFF,0x07,0xE0,0xFF,0x03,0xC0,0xFF,0x01,0x00,0x7F,0x00,/*"3",0*/
};

uint8_t number4_18[] = {
0x00,0xC0,0x01,0x00,0xE0,0x01,0x00,0xF0,0x01,0x00,0xF0,0x01,0x00,0xF8,0x01,0x00,
0xFC,0x01,0x00,0xFE,0x01,0x00,0xFE,0x01,0x00,0xFF,0x01,0x80,0xEF,0x01,0x80,0xE7,
0x01,0xC0,0xE7,0x01,0xE0,0xE3,0x01,0xF0,0xE1,0x01,0xF0,0xE1,0x01,0xF8,0xE0,0x01,
0x7C,0xE0,0x01,0xFC,0xFF,0x1F,0xFC,0xFF,0x1F,0xFC,0xFF,0x1F,0x00,0xE0,0x01,0x00,
0xE0,0x01,0x00,0xE0,0x01,0x00,0xE0,0x01,0x00,0xE0,0x01,0x00,0xE0,0x01,/*"4",0*/
};

uint8_t number5_18[] = {
0xC0,0xFF,0x07,0xC0,0xFF,0x07,0xE0,0xFF,0x07,0xE0,0x01,0x00,0xE0,0x01,0x00,0xE0,
0x01,0x00,0xF0,0x01,0x00,0xF0,0x00,0x00,0xF0,0xFC,0x00,0xF0,0xFE,0x03,0xF0,0xFF,
0x07,0xF8,0xFF,0x0F,0xF8,0x80,0x0F,0x00,0x00,0x1F,0x00,0x00,0x1E,0x00,0x00,0x1E,
0x00,0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x1E,0x78,0x00,0x1E,0xF8,0x00,0x0F,0xF0,
0x81,0x0F,0xF0,0xFF,0x07,0xE0,0xFF,0x03,0xC0,0xFF,0x01,0x00,0x7F,0x00,/*"5",0*/
};

uint8_t number6_18[] = {
0x00,0xFE,0x00,0x80,0xFF,0x03,0xC0,0xFF,0x07,0xE0,0xFF,0x0F,0xF0,0x81,0x0F,0xF8,
0x00,0x1F,0x78,0x00,0x1E,0x78,0x00,0x00,0x3C,0x00,0x00,0x3C,0xFC,0x00,0x3C,0xFF,
0x03,0xBC,0xFF,0x07,0xFC,0xFF,0x0F,0xFC,0x81,0x0F,0x7C,0x00,0x1F,0x3C,0x00,0x1E,
0x3C,0x00,0x1E,0x3C,0x00,0x1E,0x3C,0x00,0x1E,0x78,0x00,0x1E,0x78,0x00,0x0F,0xF0,
0x81,0x0F,0xF0,0xFF,0x07,0xE0,0xFF,0x07,0xC0,0xFF,0x01,0x00,0x7E,0x00,/*"6",0*/
};

uint8_t number7_18[] = {
0xF8,0xFF,0x1F,0xF8,0xFF,0x1F,0xF8,0xFF,0x1F,0x00,0x00,0x0E,0x00,0x00,0x07,0x00,
0x80,0x07,0x00,0xC0,0x03,0x00,0xE0,0x01,0x00,0xE0,0x01,0x00,0xF0,0x00,0x00,0xF0,
0x00,0x00,0x78,0x00,0x00,0x78,0x00,0x00,0x3C,0x00,0x00,0x3C,0x00,0x00,0x1E,0x00,
0x00,0x1E,0x00,0x00,0x1E,0x00,0x00,0x0F,0x00,0x00,0x0F,0x00,0x00,0x0F,0x00,0x00,
0x0F,0x00,0x80,0x07,0x00,0x80,0x07,0x00,0x80,0x07,0x00,0x80,0x07,0x00,/*"7",0*/
};

uint8_t number8_18[] = {
0x00,0x7E,0x00,0x80,0xFF,0x01,0xE0,0xFF,0x07,0xE0,0xFF,0x07,0xF0,0x81,0x0F,0xF0,
0x00,0x0F,0xF0,0x00,0x0F,0xF0,0x00,0x0F,0xE0,0x81,0x07,0xC0,0xFF,0x03,0x80,0xFF,
0x01,0x80,0xFF,0x01,0xE0,0xFF,0x07,0xF0,0x81,0x0F,0xF0,0x00,0x0F,0x78,0x00,0x1E,
0x78,0x00,0x1E,0x78,0x00,0x1E,0x78,0x00,0x1E,0x78,0x00,0x1E,0xF8,0x00,0x1F,0xF0,
0x81,0x0F,0xF0,0xFF,0x0F,0xE0,0xFF,0x07,0x80,0xFF,0x01,0x00,0x7E,0x00,/*"8",0*/
};

uint8_t number9_18[] = {
0x00,0x7F,0x00,0x80,0xFF,0x01,0xE0,0xFF,0x03,0xF0,0xFF,0x07,0xF0,0x81,0x0F,0xF8,
0x00,0x0F,0x78,0x00,0x0E,0x78,0x00,0x1E,0x78,0x00,0x1E,0x78,0x00,0x1E,0x78,0x00,
0x1E,0xF8,0x00,0x1F,0xF0,0x81,0x1F,0xF0,0xFF,0x1F,0xE0,0xFF,0x1E,0xC0,0x7F,0x1E,
0x00,0x1F,0x1E,0x00,0x00,0x1E,0x00,0x00,0x0F,0x78,0x00,0x0F,0xF8,0x80,0x0F,0xF0,
0xC1,0x07,0xF0,0xFF,0x03,0xE0,0xFF,0x03,0xC0,0xFF,0x00,0x00,0x3F,0x00,/*"9",0*/
};

// -------------------------------------------------------------
#define PCA9557_I2C_SLAVE_ADDR  0x18    //(0001 1 A2 A1 A0)

/* 控制寄存器 （CMD）*/
#define PCA9557_CONTROL_REG_0 0x00	// Input Port Register           (R)    BXXXXXXXX (Default)
#define PCA9557_CONTROL_REG_1 0x01	// Output Port Register          (R/W)  B00000000 // 引脚控制
#define PCA9557_CONTROL_REG_2 0x02	// Polarity Inversion Register   (R/W)  B11110000
#define PCA9557_CONTROL_REG_3 0x03	// Configuration Register        (R/W)  B11111111 // 模式控制
#define PCA9557_LCD_RST 0x04     // io2 B0000 0100
#define PCA9557_PRINT_POWER 0x20 // io5 B0010 0000
//---------------------------------------------------------------------------------

#define SIZE096 1
#define SIZE35 2
#define SIZE20 3 // st7789V

// #define width 320
// #define height 480
// #define width 160
// #define height 104 // 80 + 24（24是一个偏移量，具体与硬件有关系，这是一个坑，影响坐标,这个是2.0屏幕）

#define width 240
#define height 240

#define wramcmd 0X2C
#define setxcmd 0X2A
#define setycmd 0X2B

#define SIZE 4
#if SIZE == SIZE35

  #define BACKLIGHT_GPIO GPIO_NUM_2
  #define CS_GPIO GPIO_NUM_12
  #define SCL_GPIO GPIO_NUM_14
  #define SDA_GPIO GPIO_NUM_13
  #define RS_GPIO GPIO_NUM_15
  #define RST_GPIO GPIO_NUM_4

#elif SIZE == SIZE096

  #define BACKLIGHT_GPIO GPIO_NUM_12//低电平有效
  #define CS_GPIO GPIO_NUM_32
  #define SCL_GPIO GPIO_NUM_2
  #define SDA_GPIO GPIO_NUM_3
  #define RS_GPIO GPIO_NUM_33 //dc
  #define RST_GPIO GPIO_NUM_15

#elif SIZE == SIZE20

  #define BACKLIGHT_GPIO GPIO_NUM_2//低电平有效
  #define CS_GPIO GPIO_NUM_10
  #define SCL_GPIO GPIO_NUM_12
  #define SDA_GPIO GPIO_NUM_11
  #define RS_GPIO GPIO_NUM_9 //dc
  #define RST_GPIO GPIO_NUM_5
  #define SPI8 0
#else
  #define BACKLIGHT_GPIO GPIO_NUM_2//低电平有效
  #define CS_GPIO GPIO_NUM_10
  #define SCL_GPIO GPIO_NUM_12
  #define SDA_GPIO GPIO_NUM_11
  #define RS_GPIO GPIO_NUM_9 //dc
  #define RST_GPIO GPIO_NUM_5
#endif

#define CS0_L gpio_set_level(CS_GPIO, 0)  //片选
#define CS0_H gpio_set_level(CS_GPIO, 1)
#define SCLK_L gpio_set_level(SCL_GPIO, 0)  //时钟
#define SCLK_H gpio_set_level(SCL_GPIO, 1)
#define MOSI_L gpio_set_level(SDA_GPIO, 0)//MOSI
#define MOSI_H  gpio_set_level(SDA_GPIO, 1)
#define RS_L gpio_set_level(RS_GPIO, 0)// D/C
#define RS_H gpio_set_level(RS_GPIO, 1)//

#if SIZE == SIZE35
  #define BL_C gpio_set_level(BACKLIGHT_GPIO, 0)//背光
  #define BL_O gpio_set_level(BACKLIGHT_GPIO, 1)
  #define RST_L Nop()//gpio_set_level(RST_GPIO, 0) //
  #define RST_H Nop()//gpio_set_level(RST_GPIO, 1)

#elif SIZE == SIZE096
  #define BL_C gpio_set_level(BACKLIGHT_GPIO, 0)//背光
  #define BL_O gpio_set_level(BACKLIGHT_GPIO, 1)
  #define RST_L gpio_set_level(RST_GPIO, 0) //
  #define RST_H gpio_set_level(RST_GPIO, 1)
#elif SIZE == SIZE20
  #define BL_C gpio_set_level(BACKLIGHT_GPIO, 0)//背光
  #define BL_O gpio_set_level(BACKLIGHT_GPIO, 1)
  #define RST_L gpio_set_level(RST_GPIO, 0) //
  #define RST_H gpio_set_level(RST_GPIO, 1)
#endif


//------------------------------------------
void Nop(){

}

void  SendDataSPI(unsigned char dat)
{  
unsigned char i;

for(i=0; i<8; i++)
    {  
    if( (dat&0x80)!=0 ) MOSI_H;
    else MOSI_L;

    dat <<= 1;

    SCLK_L;
    SCLK_H;
    }
}

void WriteComm(unsigned int i)
{

  CS0_L;
	RS_L;
	SendDataSPI(i);

	CS0_H;

}
void WriteData(unsigned int i)
{
  CS0_L;
	RS_H;

	SendDataSPI(i);

	CS0_H;
}

extern void resetLCD(void);
void LCD_Init(void)
{
    resetLCD();
    CS0_L;
    // // RST=1;  //复位
    // Delay(200);
    // RST_H; 
    // vTaskDelay(100 / portTICK_PERIOD_MS);
    // RST_L;//复位
    // Delay(800);

    vTaskDelay(100 / portTICK_PERIOD_MS);
    // RST_H;//复位
    // Delay(800);

#if SIZE == SIZE35
    WriteComm(0xE0);
    WriteData(0x00);
    WriteData(0x07);
    WriteData(0x0f);
    WriteData(0x0D);
    WriteData(0x1B);
    WriteData(0x0A);
    WriteData(0x3c);
    WriteData(0x78);
    WriteData(0x4A);
    WriteData(0x07);
    WriteData(0x0E);
    WriteData(0x09);
    WriteData(0x1B);
    WriteData(0x1e);
    WriteData(0x0f);
    
    WriteComm(0xE1);
    WriteData(0x00);
    WriteData(0x22);
    WriteData(0x24);
    WriteData(0x06);
    WriteData(0x12);
    WriteData(0x07);
    WriteData(0x36);
    WriteData(0x47);
    WriteData(0x47);
    WriteData(0x06);
    WriteData(0x0a);
    WriteData(0x07);
    WriteData(0x30);
    WriteData(0x37);
    WriteData(0x0f);

    WriteComm(0xC0);
    WriteData(0x10);
    WriteData(0x10);

    WriteComm(0xC1);
    WriteData(0x41);

    WriteComm(0xC5);
    WriteData(0x00);
    WriteData(0x22);
    WriteData(0x80);
    
    WriteComm(0x36);
    WriteData(0x48);
    
    WriteComm(0x3A); //Interface Mode Control
    WriteData(0x66);
    
    WriteComm(0XB0);  //Interface Mode Control  
    WriteData(0x00);
    WriteComm(0xB1);//Frame rate 70HZ  
    WriteData(0xB0);
    WriteData(0x11);
    WriteComm(0xB4);
    WriteData(0x02);
    WriteComm(0xB6); //RGB/MCU Interface Control
    WriteData(0x02);
    WriteData(0x02);
    
    WriteComm(0xB7);
    WriteData(0xC6);

    //WriteComm(0XBE);
    //WriteData(0x00);
    //WriteData(0x04);

    WriteComm(0xE9);
    WriteData(0x00);

    WriteComm(0XF7);
    WriteData(0xA9);
    WriteData(0x51);
    WriteData(0x2C);
    WriteData(0x82);

    WriteComm(0x11);
    // delay_ms(120);
    vTaskDelay(10 / portTICK_PERIOD_MS);
    WriteComm(0x29);
    WriteComm(0x2c);

#elif SIZE == SIZE096
    WriteComm(0x11);
    vTaskDelay(1000/ portTICK_PERIOD_MS);

    WriteComm(0xB1);//------------------------------------ST7735S Frame Rate-----------------------------------------//
    WriteData(0x05);
    WriteData(0x3C);
    WriteData(0x3C);

    WriteComm(0xB2);
    WriteData(0x05);
    WriteData(0x3C);
    WriteData(0x3C);

    WriteComm(0xB3);
    WriteData(0x05);
    WriteData(0x3C);
    WriteData(0x3C);
    WriteData(0x05);
    WriteData(0x3C);
    WriteData(0x3C);//------------------------------------End ST7735S Frame Rate-----------------------------------------//

    WriteComm(0xB4);//Dot inversion
    WriteData(0x03);

    WriteComm(0xC0);//------------------------------------ST7735S Power Sequence-----------------------------------------//
    WriteData(0x0E);
    WriteData(0x0E);
    WriteData(0x04);

    WriteComm(0xC1);
    WriteData(0xC0);

    WriteComm(0xC2);
    WriteData(0x0D);
    WriteData(0x00);

    WriteComm(0xC3);
    WriteData(0x8D);
    WriteData(0x2A);

    WriteComm(0xC4);
    WriteData(0x8D);
    WriteData(0xEE);//---------------------------------End ST7735S Power Sequence-------------------------------------//

    WriteComm(0xC5);//VCOM
    WriteData(0x04);

    WriteComm(0x36);//MX, MY, RGB mode  刷屏模式 A8： 横屏  68：横屏翻转
    WriteData(0x68);

    WriteComm(0x3a);  // 颜色配置05H： 56506H： 666
    WriteData(0x05);


    WriteComm(0xE0);
    WriteData(0x05);
    WriteData(0x1A);
    WriteData(0x0B);
    WriteData(0x15);
    WriteData(0x3D);
    WriteData(0x38);
    WriteData(0x2E);
    WriteData(0x30);
    WriteData(0x2D);
    WriteData(0x28);
    WriteData(0x30);
    WriteData(0x3B);
    WriteData(0x00);
    WriteData(0x01);
    WriteData(0x02);
    WriteData(0x10);

    WriteComm(0xE1);
    WriteData(0x05);
    WriteData(0x1A);
    WriteData(0x0B);
    WriteData(0x15);
    WriteData(0x36);
    WriteData(0x2E);
    WriteData(0x28);
    WriteData(0x2B);
    WriteData(0x2B);
    WriteData(0x28);
    WriteData(0x30);
    WriteData(0x3B);
    WriteData(0x00);
    WriteData(0x01);
    WriteData(0x02);
    WriteData(0x10);
    WriteComm(0x29);

#elif SIZE == SIZE20

    WriteComm(0x11);
    vTaskDelay(1000/ portTICK_PERIOD_MS);
    WriteComm(0x36);
    WriteData(0xA0); // 扫描方向 0xA0 翻转：0x70

    WriteComm(0x3A);
    WriteData(0x05);  //0x05( 65K Color)

    WriteComm(0x21);

    WriteComm(0xB2);
    WriteData(0x05);
    WriteData(0x05);
    WriteData(0x00);
    WriteData(0x33);
    WriteData(0x33);

    WriteComm(0xB7);
    WriteData(0x23);

    WriteComm(0xBB);
    WriteData(0x22);

    WriteComm(0xC0);
    WriteData(0x2C);

    WriteComm(0xC2);
    WriteData(0x01);

    WriteComm(0xC3);
    WriteData(0x13);

    WriteComm(0xC4);
    WriteData(0x20);

    WriteComm(0xC6);
    WriteData(0x0F);

    WriteComm(0xD0);
    WriteData(0xA4);
    WriteData(0xA1);

    WriteComm(0xD6);
    WriteData(0xA1);

    WriteComm(0xE0);
    WriteData(0x70);
    WriteData(0x06);
    WriteData(0x0C);
    WriteData(0x08);
    WriteData(0x09);
    WriteData(0x27);
    WriteData(0x2E);
    WriteData(0x34);
    WriteData(0x46);
    WriteData(0x37);
    WriteData(0x13);
    WriteData(0x13);
    WriteData(0x25);
    WriteData(0x2A);

    WriteComm(0xE1);
    WriteData(0x70);
    WriteData(0x04);
    WriteData(0x08);
    WriteData(0x09);
    WriteData(0x07);
    WriteData(0x03);
    WriteData(0x2C);
    WriteData(0x42);
    WriteData(0x42);
    WriteData(0x38);
    WriteData(0x14);
    WriteData(0x14);
    WriteData(0x27);
    WriteData(0x2C);

    WriteComm(0x29);     //Display on

#else
    WriteComm(0x11);
    vTaskDelay(1000/ portTICK_PERIOD_MS);
    // WriteComm(0x3A);
    // WriteData(0xA0); // 扫描方向 0xA0 翻转：0x70

    WriteComm(0x3A);
    WriteData(0x05);  //0x05( 65K Color)

    WriteComm(0x21);

    WriteComm(0xB2);
    WriteData(0x0C);
    WriteData(0x0C);
    WriteData(0x00);
    WriteData(0x33);
    WriteData(0x33);

    WriteComm(0xB7);
    WriteData(0x35);

    WriteComm(0xBB);
    WriteData(0x32);

    WriteComm(0xC0);
    WriteData(0x2C);

    WriteComm(0xC2);
    WriteData(0x01);

    WriteComm(0xC3);
    WriteData(0x15);

    WriteComm(0xC4);
    WriteData(0x20);

    WriteComm(0xC6);
    WriteData(0x0F);

    WriteComm(0xD0);
    WriteData(0xA4);
    WriteData(0xA1);

    // WriteComm(0xD6);
    // WriteData(0xA1);

    WriteComm(0xE0);
    WriteData(0xD0);
    WriteData(0x08);
    WriteData(0x0E);
    WriteData(0x09);
    WriteData(0x09);
    WriteData(0x05);
    WriteData(0x31);
    WriteData(0x33);
    WriteData(0x48);
    WriteData(0x17);
    WriteData(0x14);
    WriteData(0x15);
    WriteData(0x31);
    WriteData(0x34);

    WriteComm(0xE1);
    WriteData(0xD0);
    WriteData(0x08);
    WriteData(0x0E);
    WriteData(0x09);
    WriteData(0x09);
    WriteData(0x05);
    WriteData(0x31);
    WriteData(0x33);
    WriteData(0x48);
    WriteData(0x17);
    WriteData(0x14);
    WriteData(0x15);
    WriteData(0x31);
    WriteData(0x34);

    WriteComm(0x29);     //Display on
#endif
}


void drawFrameBufferBigger(uint8_t* buff,uint16_t size,uint16_t color,uint16_t bgcolor)
{
        for (uint16_t i = 0 ;i < size ;i++){
            for(uint8_t j = 0;j < 8;j++){
                if(((buff[i] >> j) & 0x01)){
#if SPI8
                    WriteData(color >> 8);
                    WriteData(color & 0xff);
                }
                else{
                    WriteData(bgcolor >> 8);
                    WriteData(bgcolor & 0xff);
                }
            }
#else
                    WriteData(color);
                }
                else{
                    WriteData(bgcolor);
                }
            }
#endif

        }
}




void drawPicture(uint16_t xStar,uint16_t yStar,uint16_t weight,uint16_t hight,uint8_t* buff,uint16_t color,uint16_t bgcolor){
#if SPI8
    WriteComm(setxcmd);
    WriteData(xStar >> 8);WriteData(xStar & 0xff);
    WriteData((xStar + weight - 1)>>8);WriteData((xStar + weight - 1)&0xff);
    WriteComm(setycmd);
    WriteData(yStar >> 8);WriteData(yStar & 0xff);
    WriteData((yStar + hight - 1) >> 8);WriteData((yStar + hight -1) &0Xff);

	WriteComm(wramcmd);

#else
    WriteComm(setxcmd);
    WriteData(xStar);
    WriteData((xStar + weight - 1));
    WriteComm(setycmd);
    WriteData(yStar);
    WriteData((yStar + hight - 1));

	WriteComm(wramcmd);
#endif
    drawFrameBufferBigger(buff,(weight * hight/8),color,bgcolor);
}
//------------------------------------------
void gpio_init(){
      // PIN_FUNC_SELECT( IO_MUX_GPIO13_REG, PIN_FUNC_GPIO)
      gpio_reset_pin(CS_GPIO);
      gpio_set_direction(CS_GPIO, GPIO_MODE_OUTPUT);
      gpio_reset_pin(SCL_GPIO);
      gpio_set_direction(SCL_GPIO, GPIO_MODE_OUTPUT);
      gpio_reset_pin(SDA_GPIO);
      gpio_set_direction(SDA_GPIO, GPIO_MODE_OUTPUT);
      gpio_reset_pin(RS_GPIO);
      gpio_set_direction(RS_GPIO, GPIO_MODE_OUTPUT);

#if 0 // 有无背光灯

      gpio_reset_pin(BACKLIGHT_GPIO);
      gpio_set_direction(BACKLIGHT_GPIO, GPIO_MODE_OUTPUT);
      gpio_reset_pin(RST_GPIO);
      gpio_set_direction(RST_GPIO, GPIO_MODE_OUTPUT); 
      BL_O;
#endif
      CS0_H;
      SCLK_H;
      MOSI_L;  //MOSI io13
      RS_H; 
      RS_L; 
}

void LCD_Clear(uint32_t color)
{
	uint32_t index=0; 
	uint32_t totalpoint=width;
	totalpoint*=height; 	

  WriteComm(setxcmd); 
  WriteData(0);WriteData(0);
  WriteData((width-1)>>8);WriteData((width-1)&0XFF);
  WriteComm(setycmd); 
  WriteData(0);WriteData(0);
  WriteData((height-1)>>8);WriteData((height-1)&0XFF);  

	WriteComm(0x2c);
	for(index=0;index<totalpoint;index++)
	{
    // WriteData(color>>16);
    WriteData(color>>8);
    WriteData(color & 0xff);
	}
}

void setSetMemoryArea(uint16_t xStar,uint16_t xEnd,uint16_t yStar,uint16_t yEnd){

  WriteComm(setxcmd);
  WriteData(xStar >> 8);WriteData(xStar & 0xff);
  WriteData((xStar)>>8);WriteData((xStar)&0xff);
  WriteComm(setycmd);
  WriteData(yStar >> 8);WriteData(yStar & 0xff);
  WriteData((yEnd) >> 8);WriteData((yEnd)  &0Xff);

	WriteComm(0x2c);

}

// void writeMemory(uint16_t xStar,uint16_t xEnd,uint16_t yStar,uint16_t yEnd){
//   WriteComm(0x2c);

//   WriteData();
// }

void drawBlock(uint16_t xStar,uint16_t yStar,uint16_t xEnd,uint16_t yEnd,uint32_t color)
{
	uint32_t index = 0; 
	uint32_t totalpoint = (xEnd - xStar + 1) * (yEnd - yStar + 1);

  WriteComm(setxcmd);
  WriteData(xStar >> 8);WriteData(xStar & 0xff);
  WriteData((xEnd)>>8);WriteData((xEnd)&0xff);
  WriteComm(setycmd);
  WriteData(yStar >> 8);WriteData(yStar & 0xff);
  WriteData((yEnd) >> 8);WriteData((yEnd)  &0Xff);

	WriteComm(0x2c);

	for(index=0;index < totalpoint;index++)
	{
    // WriteData(color>>16);
    WriteData(color >> 8);
    WriteData(color & 0xff);
	}

}

void rollInit(void){ // 滚动的初始化，设置滚动区域，在lcd 初始化之后调用
  WriteComm(0x33); 
  WriteData(0);
  WriteData(0);
  WriteData(0>>8);
  WriteData((162) & 0xff);
  WriteData(0);
  WriteData(0);
}
void startRoll(uint8_t i){
  WriteComm(0x37); 
  WriteData(0);
  WriteData(i);
}

void keepRoll1(void){  // 开始滚动，1和2的区别是方向不同
    uint8_t time = 0;
    while(1) {
      startRoll(time);
      time++;
      if(time > 160)
        time = 0;
      vTaskDelay(10 / portTICK_PERIOD_MS);
      }
}

void keepRoll2(void){
    uint8_t time = 160;
    while(1) {
      startRoll(time);
      time--;
      if(time == 0)
        time = 160;
      vTaskDelay(10 / portTICK_PERIOD_MS);
    }
}


void uart_init(int baud_rate, int tx_pin, int rx_pin) {
    uart_config_t uart_config = {
        .baud_rate = baud_rate,
        .data_bits = UART_DATA_8_BITS,
        .parity    = UART_PARITY_EVEN,
        .stop_bits = UART_STOP_BITS_1,
        .flow_ctrl = UART_HW_FLOWCTRL_DISABLE,
        .source_clk = UART_SCLK_APB,
    };
    uart_param_config(UART_NUM_1, &uart_config);
    uart_set_pin(UART_NUM_1,tx_pin ,-1 , UART_PIN_NO_CHANGE, UART_PIN_NO_CHANGE);
    uart_driver_install(UART_NUM_1, 1024, 0, 0, NULL, 0);
}


// 扩展芯片
void pca9557Readreg(uint8_t cmd,uint8_t* buff)
{
  if (isIdle(PCA9557_I2C_SLAVE_ADDR << 1))
  {
    i2cWriteByte(cmd);
    i2cStop();
  }
  else
  {
    printf("PCA9557_I2C_SLAVE_ADDR don't alive\r\n");
  }
  if (isIdle(PCA9557_I2C_SLAVE_ADDR << 1 | 0x01))
  {
    *buff = i2cReadByte(0);
    i2cStop();
    printf("ioConfig = %x\r\n",*buff);
  }

}

void pca9557Setreg(uint8_t cmd,uint8_t value)
{
  if (isIdle(PCA9557_I2C_SLAVE_ADDR << 1))
  {
    i2cWriteByte(cmd);
    i2cWriteByte(value);
    i2cStop();
  }
  else
  {
    printf("PCA9557_I2C_SLAVE_ADDR don't alive\r\n");
  }

}


void pca9557Init(void)
{
  // uint8_t ioConfig;

  i2cGpioConfiguration();
  uint8_t v;
  pca9557Readreg(PCA9557_CONTROL_REG_1,&v);
  printf("PCA9557_CONTROL_REG_1 =%x\r\n",v);
  pca9557Readreg(PCA9557_CONTROL_REG_3,&v);
  printf("PCA9557_CONTROL_REG_3 =%x\r\n",v);

  pca9557Setreg(PCA9557_CONTROL_REG_3,0x0); // 初始化

  pca9557Setreg(PCA9557_CONTROL_REG_1,0x00);

  pca9557Readreg(PCA9557_CONTROL_REG_1,&v);
  printf("PCA9557_CONTROL_REG_1 =%x\r\n",v);
  pca9557Readreg(PCA9557_CONTROL_REG_3,&v);
  printf("PCA9557_CONTROL_REG_3 =%x\r\n",v);

}
void resetLCD(void)
{
  pca9557Setreg(PCA9557_CONTROL_REG_1,0x0);
  vTaskDelay(100 / portTICK_PERIOD_MS);
  pca9557Setreg(PCA9557_CONTROL_REG_1,0x04);
}
//-------------------------------------


// 步进电机
#define HIGH 1
#define LOW 0

#define INA GPIO_NUM_41
#define INB GPIO_NUM_42
#define INC GPIO_NUM_44
#define IND GPIO_NUM_43

#define delaytime 20
uint8_t step = 0;
void stepMotor(bool type, int speed) // 执行1次，步进电机转动1步，2步对应一个像素
{
    if (type) {
        switch (step % 4) {
            case 0:
                gpio_set_level(INA, LOW);
                gpio_set_level(INB, HIGH);
                gpio_set_level(INC, HIGH);
                gpio_set_level(IND, LOW);
                break;
            case 1:
                gpio_set_level(INA, HIGH);
                gpio_set_level(INB, LOW);
                gpio_set_level(INC, HIGH);
                gpio_set_level(IND, LOW);
                break;
            case 2:
                gpio_set_level(INA, HIGH);
                gpio_set_level(INB, LOW);
                gpio_set_level(INC, LOW);
                gpio_set_level(IND, HIGH);
                break;
            case 3:
                gpio_set_level(INA, LOW);
                gpio_set_level(INB, HIGH);
                gpio_set_level(INC, LOW);
                gpio_set_level(IND, HIGH);
                break;
        }
    } else {
        switch (step % 4) {
            case 0:
                gpio_set_level(INA, LOW);
                gpio_set_level(INB, HIGH);
                gpio_set_level(INC, LOW);
                gpio_set_level(IND, HIGH);
                break;
            case 1:
                gpio_set_level(INA, HIGH);
                gpio_set_level(INB, LOW);
                gpio_set_level(INC, LOW);
                gpio_set_level(IND, HIGH);
                break;
            case 2:
                gpio_set_level(INA, HIGH);
                gpio_set_level(INB, LOW);
                gpio_set_level(INC, HIGH);
                gpio_set_level(IND, LOW);
                break;
            case 3:
                gpio_set_level(INA, LOW);
                gpio_set_level(INB, HIGH);
                gpio_set_level(INC, HIGH);
                gpio_set_level(IND, LOW);
                break;
        }
    }
    step++;
    // 等待一段时间
    vTaskDelay(speed / portTICK_PERIOD_MS);
}

void intMx1508s(void)
{
    // 设置步进电机引脚为输出模式
    gpio_reset_pin(INA);
    gpio_set_direction(INA, GPIO_MODE_OUTPUT);
    gpio_reset_pin(INB);
    gpio_set_direction(INB, GPIO_MODE_OUTPUT);
    gpio_reset_pin(INC);
    gpio_set_direction(INC, GPIO_MODE_OUTPUT);
    gpio_reset_pin(IND);
    gpio_set_direction(IND, GPIO_MODE_OUTPUT);
#if 0
    for (int i = 0; i < setps; i++) {
      if (type) {
          // 设置步进电机引脚的电压模式
          gpio_set_level(INA, LOW);
          gpio_set_level(INB, HIGH);
          gpio_set_level(INC, HIGH);
          gpio_set_level(IND, LOW);

          // 等待一段时间
          vTaskDelay(speed / portTICK_PERIOD_MS);

          // 设置步进电机引脚的电压模式
          gpio_set_level(INA, HIGH);
          gpio_set_level(INB, LOW);
          gpio_set_level(INC, HIGH);
          gpio_set_level(IND, LOW);

          // 等待一段时间
          vTaskDelay(speed / portTICK_PERIOD_MS);

          gpio_set_level(INA, HIGH);
          gpio_set_level(INB, LOW);
          gpio_set_level(INC, LOW);
          gpio_set_level(IND, HIGH);

          // // 等待一段时间
          vTaskDelay(speed / portTICK_PERIOD_MS);

          // 设置步进电机引脚的电压模式
          gpio_set_level(INA, LOW);
          gpio_set_level(INB, HIGH);
          gpio_set_level(INC, LOW);
          gpio_set_level(IND, HIGH);

          // // 等待一段时间
          vTaskDelay(speed / portTICK_PERIOD_MS);
      }
      else
      {
        gpio_set_level(INA, LOW);
        gpio_set_level(INB, HIGH);
        gpio_set_level(INC, LOW);
        gpio_set_level(IND, HIGH);

        // // 等待一段时间
        vTaskDelay(speed / portTICK_PERIOD_MS);

        gpio_set_level(INA, HIGH);
        gpio_set_level(INB, LOW);
        gpio_set_level(INC, LOW);
        gpio_set_level(IND, HIGH);


        // // 等待一段时间
        vTaskDelay(speed / portTICK_PERIOD_MS);

        gpio_set_level(INA, HIGH);
        gpio_set_level(INB, LOW);
        gpio_set_level(INC, HIGH);
        gpio_set_level(IND, LOW);
        // 等待一段时间
        vTaskDelay(speed / portTICK_PERIOD_MS);

        gpio_set_level(INA, LOW);
        gpio_set_level(INB, HIGH);
        gpio_set_level(INC, HIGH);
        gpio_set_level(IND, LOW);
        // 等待一段时间
        vTaskDelay(speed / portTICK_PERIOD_MS);
      }
    }
#endif

}

void deintMx1508s(void) // 使用后失能，不然长时间步进会电机发烫
{
    gpio_set_level(INA, LOW);
    gpio_set_level(INB, LOW);
    gpio_set_level(INC, LOW);
    gpio_set_level(IND, LOW);
    gpio_reset_pin(INA);
    gpio_set_direction(INA, GPIO_MODE_INPUT);
    gpio_reset_pin(INB);
    gpio_set_direction(INB, GPIO_MODE_INPUT);
    gpio_reset_pin(INC);
    gpio_set_direction(INC, GPIO_MODE_INPUT);
    gpio_reset_pin(IND);
    gpio_set_direction(IND, GPIO_MODE_INPUT);
}

//-----------------------------------------------------------------
// 打印头
#define PRINT_DI GPIO_NUM_40 // data in
#define PRINT_SCLK GPIO_NUM_39 // clock
#define PRINT_LAT GPIO_NUM_38 // lanch (low active)
#define PRINT_STB GPIO_NUM_48 // strobe (low active)
#define HEAT_TIME 15 // 20ms


void openPrintPower(void)
{
  uint8_t v;
  pca9557Readreg(PCA9557_CONTROL_REG_1,&v);
  pca9557Setreg(PCA9557_CONTROL_REG_1,v | PCA9557_PRINT_POWER); // 拉高电源线
}

void closePrintPower(void)
{
  uint8_t v;
  pca9557Readreg(PCA9557_CONTROL_REG_1,&v);
  pca9557Setreg(PCA9557_CONTROL_REG_1,(v & ~PCA9557_PRINT_POWER)); // 拉低电源线
}

#define PRINT_DI_H gpio_set_level(PRINT_DI, 1)
#define PRINT_DI_L gpio_set_level(PRINT_DI, 0)

#define PRINT_CLK_H gpio_set_level(PRINT_SCLK, 1)
#define PRINT_CLK_L gpio_set_level(PRINT_SCLK, 0)

#define PRINT_STB_H gpio_set_level(PRINT_STB, 1)
#define PRINT_STB_L gpio_set_level(PRINT_STB, 0)

#define PRINT_LAT_H gpio_set_level(PRINT_LAT, 1)
#define PRINT_LAT_L gpio_set_level(PRINT_LAT, 0)
#define printf_delay 0

void Delay_us(uint16_t time)
{
  for(uint16_t i = 0;i < time;i++)
  {
    for(uint16_t j = 0;j < time;j++);
  }
}

uint8_t testData2[] =
{
0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xF0,0x07,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x00,0x00,0x00,0x00,
0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x80,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x00,/*"未命名文件",0*/

};

uint8_t testData1[] =
{

0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x0E,0xFC,0x07,0xF8,0xF3,0x0F,0xFC,
0xF7,0x3F,0x00,0x00,0x00,0x1F,0xFC,0x0F,0xFE,0xF7,0x3F,0xFC,0xF7,0x3F,0x00,0x00,
0x00,0x1F,0x1C,0x1E,0x1F,0x77,0x78,0x1C,0x70,0x00,0x00,0x00,0x80,0x3F,0x1C,0x9C,
0x07,0x70,0xF0,0x1C,0x70,0x00,0x00,0x00,0x80,0x3B,0x1C,0x9C,0x03,0x70,0xE0,0x1C,
0x70,0x00,0x00,0x00,0x80,0x3B,0x1C,0xCE,0x03,0x70,0xE0,0x1D,0x70,0x00,0x00,0x00,
0xC0,0x7B,0xFC,0xC7,0x03,0x70,0xE0,0xFD,0xF7,0x3F,0x00,0x00,0xC0,0x71,0xFC,0xCF,
0x03,0x70,0xE0,0xFD,0xF7,0x3F,0x00,0x00,0xC0,0x71,0x1C,0xDE,0x03,0x70,0xE0,0x1D,
0x70,0x00,0x00,0x00,0xE0,0xFF,0x1C,0xBC,0x03,0x70,0xE0,0x1C,0x70,0x00,0x00,0x00,
0xE0,0xFF,0x1C,0xBC,0x07,0x70,0xF0,0x1C,0x70,0x00,0x00,0x00,0xF0,0xE0,0x1D,0x1E,
0x0F,0x77,0x78,0x1C,0x70,0x00,0x00,0x00,0xF0,0xE0,0xFD,0x1F,0xFE,0xF7,0x3F,0xFC,
0x77,0x00,0x00,0x00,0x70,0xC0,0xFD,0x07,0xFC,0xF1,0x0F,0xFC,0x77,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,/*"C:\Users\Administrator\Desktop\无标题.bmp",0*/
};

uint8_t testData[] = {
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,
0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0x00,0xF0,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0x1F,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,
0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0x00,0xF0,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,
0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,
0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,
0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,
0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0xFC,0xF8,0xFF,0xFF,0xFF,
0xFF,0xFF,0x1F,0x00,0x00,0xF0,0x03,0xFC,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,
0x00,0xF0,0x03,0xFC,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0x00,0xF0,0x03,0xFC,
0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0x00,0xF0,0x03,0xFC,0xF8,0xFF,0xFF,0xFF,
0xFF,0xFF,0x1F,0x00,0x00,0xF0,0x03,0xFC,0xF8,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,
0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,
0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,
0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,
0x7E,0xC0,0x1F,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x7E,0xC0,0x1F,0x00,
0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x7E,0xC0,0x1F,0x00,0x00,0xF0,0xFF,0xFF,
0xFF,0xFF,0xFF,0x3F,0x7E,0xC0,0x1F,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,
0x7E,0xC0,0x1F,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0x3F,0x7E,0xC0,0x1F,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,
0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,
0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,
0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,
0x00,0xF0,0x03,0x00,0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0x03,0x00,
0x00,0x00,0x00,0x00,0x00,0xC0,0x1F,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0x1F,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,
0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0x00,0xF0,0xFF,0xFF,
0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,
0xFF,0xFF,0x1F,0x00,0x00,0xF0,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0xFF,0x1F,0x00,
0x00,0x00,0x00,0x00,0x00,0xE0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xE0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x0F,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x0F,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xE0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xE0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x0F,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x0F,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0xE0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0xE0,0x0F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xE0,0x0F,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,
0x00,0x00,0x00,0xFC,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,
0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFF,0xFF,0xFF,0xFF,
0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0xFC,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,
0x00,0x00,0x00,0xFC,0xFF,0xFF,0xFF,0xFF,0x7F,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
};

void luomuInit(void)
{
  openPrintPower();
  gpio_reset_pin(PRINT_DI);
  gpio_set_direction(PRINT_DI, GPIO_MODE_OUTPUT);
  gpio_reset_pin(PRINT_SCLK);
  gpio_set_direction(PRINT_SCLK, GPIO_MODE_OUTPUT);
  gpio_reset_pin(PRINT_LAT);
  gpio_set_direction(PRINT_LAT, GPIO_MODE_OUTPUT);
  gpio_reset_pin(PRINT_STB);
  gpio_set_direction(PRINT_STB, GPIO_MODE_OUTPUT);
  PRINT_CLK_L;
  PRINT_STB_H;
  // PRINT_LAT_H;
} 

void dataTransmitBit(bool bit)
{
  if(bit)
  {
    PRINT_DI_H;
  }
  else
  {
    PRINT_DI_L;
  }
  Delay_us(printf_delay);
  PRINT_CLK_L;
  PRINT_CLK_H;
  Delay_us(printf_delay);
}

void dataTransmit(uint16_t data) // 低位在前逐行式
{
  for(uint8_t i = 0;i < 8;i++)
  {
    dataTransmitBit(data & 0x01);
    data = data >> 1;
  }
}
// 一行96个像素点
void printfTestOneLine(uint8_t *data) // 打印时间20ms以上保证清晰，同时加热所有点会导致电压不够，esp32会欠压启动不了，所以选择先打印一半再打印另一半
{
  PRINT_LAT_H;
  for(uint16_t i = 0;i < 6; i++)
  {
    // dataTransmit(0xFF);
    dataTransmit(data[i]);
  }
  for(uint16_t i = 0;i < 6; i++) // 发送完96个像素点（12字节后锁存，然后加热）
  {
    dataTransmit(0x00);
  }
  PRINT_LAT_L;
  PRINT_LAT_H; // 数据锁存
  PRINT_STB_L;
  vTaskDelay(HEAT_TIME / portTICK_PERIOD_MS); // 加热时间
  PRINT_STB_H;
  for(uint16_t i = 0;i < 6; i++)
  {
    dataTransmit(0x00);
  }
  for(uint16_t i = 0;i < 6; i++) // 打印另一半
  {
    // dataTransmit(0xFF);
    dataTransmit(data[6 + i]);
  }
  PRINT_LAT_L;
  // Delay_us(1);
  PRINT_LAT_H;
  PRINT_STB_L;
  vTaskDelay(HEAT_TIME / portTICK_PERIOD_MS);
  PRINT_STB_H;

}

void printfTest(uint8_t *data, uint16_t n)
{
    for (uint16_t line = 0; line < n; line++)
    {
        printfTestOneLine(&data[line*12]);
        stepMotor(1,20);
        stepMotor(1,20);        
    }

    deintMx1508s();
    closePrintPower();
}


#if 0 //蜂鸣器
#include "driver/ledc.h"

ledc_timer_config_t ledc_timer = {
        .duty_resolution = LEDC_TIMER_13_BIT, // 设置占空比分辨率为13位
        .freq_hz = 2700, // 设置PWM频率为2.7kHz
        .speed_mode = LEDC_LOW_SPEED_MODE,
        .timer_num = LEDC_TIMER_0
    };

ledc_channel_config_t ledc_channel = {
    .channel    = LEDC_CHANNEL_0,
    .duty       = 0,
    .gpio_num   = GPIO_NUM_8,
    .speed_mode = LEDC_LOW_SPEED_MODE,
    .timer_sel  = LEDC_TIMER_0
};
void beepInit(void)
{

    ledc_timer_config(&ledc_timer);

    // 配置 LEDC Channel

    ledc_channel_config(&ledc_channel);

    // 启动 PWM
    ledc_fade_func_install(0);
    ledc_set_duty(ledc_channel.speed_mode, ledc_channel.channel, 0); // 设置占空比为50%
    ledc_update_duty(ledc_channel.speed_mode, ledc_channel.channel);
}

void beepContorl(uint8_t vol,uint16_t fre)
{
  if (vol>100)
    vol = vol % 100;
  if (fre > 5000)
    fre = fre % 5000;
  ledc_timer.freq_hz = fre;
  ledc_timer_config(&ledc_timer);
  ledc_channel.duty = 4096 * vol / 100;
  ledc_channel_config(&ledc_channel);
  ledc_set_duty(ledc_channel.speed_mode, ledc_channel.channel, 4096 * vol / 100); // 设置占空比为50%
  ledc_update_duty(ledc_channel.speed_mode, ledc_channel.channel);
  printf("vol = %d,fre = %d\r\n",vol,fre);
}
#endif
// -----------------------------------

// RTC
#if 0
#define REG_CTRL_STATUS_1 0x00
#define REG_CTRL_STATUS_2 0x01
#define REG_DATETIME_SEC 0x02
#define REG_CLOCKOUT_CTL 0x0D
#define REG_TIMER_CONTROL 0x0E
#define SLAVE_ADDR (0xA2 >> 1)
#define BinToBCD(bin) ((((bin) / 10) << 4) + ((bin) % 10))

typedef struct
{
    uint8_t second; // 0..59
    uint8_t minute; // 0..59
    uint8_t hour; // 0..23
    uint8_t day; // 1..31
    uint8_t weekday; // 0..6 (0 means Sunday)
    uint8_t month; // 1..12
    uint16_t year; // 2021...
} rtc_dateTime_t;


int i2cs_tx_data(uint8_t devAddr7, uint8_t addr, uint8_t* buf, uint8_t size) {
    int i;
    i2cStart();
    if (i2cWriteByte(devAddr7 << 1) == 0) {
        i2cStop();
        return -1;
    }
    if (i2cWriteByte(addr) == 0) {
        i2cStop();
        return -2;
    }
    for (i = 0; i < size; i++) {
        if (i2cWriteByte(*buf++) == 0) {
            i2cStop();
            return -3;
        }
    }
    i2cStop();
    return 0;
}

int i2cs_rx_data(uint8_t devAddr7, uint8_t addr, uint8_t* buf, uint8_t size) {
    uint8_t i;
    i2cStart();
    if (i2cWriteByte(devAddr7 << 1) == 0) {
        i2cStop();
        return -1;
    }
    if (i2cWriteByte(addr) == 0) {
        i2cStop();
        return -2;
    }
    i2cStart();
    if (i2cWriteByte((devAddr7 << 1) + 1) == 0) {
        i2cStop();
        return -3;
    }
    for (i = 0; i < (size - 1); i++) {
        *buf++ = i2cReadByte(1);
    }
    *buf++ = i2cReadByte(0);

    i2cStop();
    return 0;
}

void hal_rtc_time_init(void) {
    int ret;
    uint8_t data = 0;

    data = 0;
    ret = i2cs_tx_data(SLAVE_ADDR, REG_CTRL_STATUS_1, &data, sizeof(data));
    if (ret) printf("ret=%d\r\n", ret);

    uint8_t mode = 0;    // PCF_ALARM_INTERRUPT_ENABLE | PCF_TIMER_INTERRUPT_ENABLE;
    data = mode & 0x13;  // Mask unnecessary bits
    ret = i2cs_tx_data(SLAVE_ADDR, REG_CTRL_STATUS_2, &data, sizeof(data));
    if (ret) printf("ret=%d\r\n", ret);
}

int8_t rtc_get_datetime(rtc_dateTime_t* dt) {
    uint8_t buffer[7];
    int ret = i2cs_rx_data(SLAVE_ADDR, REG_DATETIME_SEC, buffer, sizeof(buffer));
    if (ret) {
        printf("ret=%d\r\n", ret);
        return -1;
    }
    for (uint8_t i=0;i<7;i++)
    {
      printf("buffer=%x\r\n", buffer[i]);
    }
    dt->second = (((buffer[0] >> 4) & 0x07) * 10) + (buffer[0] & 0x0F);
    dt->minute = (((buffer[1] >> 4) & 0x07) * 10) + (buffer[1] & 0x0F);
    dt->hour = (((buffer[2] >> 4) & 0x03) * 10) + (buffer[2] & 0x0F);
    dt->day = (((buffer[3] >> 4) & 0x03) * 10) + (buffer[3] & 0x0F);
    dt->weekday = (buffer[4] & 0x07);
    dt->month = ((buffer[5] >> 4) & 0x01) * 10 + (buffer[5] & 0x0F);
    dt->year = 1900 + ((buffer[6] >> 4) & 0x0F) * 10 + (buffer[6] & 0x0F);

    if (buffer[5] & 0x80) {  // century bit is set, means 2000 + ...
        dt->year += 100;
    }

    if (buffer[0] & 0x80) {  // Clock integrity not guaranted (oscillator has stopped or been interrupted)
        return 1;
    }
    return 0;
}

int8_t rtc_set_datetime(rtc_dateTime_t* dt) {
    int ret;
    uint8_t buffer[7];

    if (dt->second >= 60 || dt->minute >= 60 || dt->hour >= 24 || dt->day > 32 || dt->weekday > 6 || dt->month > 12 || dt->year < 1900 || dt->year >= 3000) {
        printf("invalid datetime\r\n");
        return -1;
    }

    buffer[0] = BinToBCD(dt->second) & 0x7F;
    buffer[1] = BinToBCD(dt->minute) & 0x7F;
    buffer[2] = BinToBCD(dt->hour) & 0x3F;
    buffer[3] = BinToBCD(dt->day) & 0x3F;
    buffer[4] = BinToBCD(dt->weekday) & 0x07;
    buffer[5] = BinToBCD(dt->month) & 0x1F;

    if (dt->year >= 2000) {
        buffer[5] |= 0x80;  // century bit
        buffer[6] = BinToBCD(dt->year - 2000);
    } else {
        buffer[6] = BinToBCD(dt->year - 1900);
    }
        for (uint8_t i=0;i<7;i++)
    {
      printf("wbuffer=%x\r\n", buffer[i]);
    }
    ret = i2cs_tx_data(SLAVE_ADDR, REG_DATETIME_SEC, buffer, sizeof(buffer));
    if (ret) {
        printf("ret=%d\r\n", ret);
        return -1;
    }
    return 0;
}

void rtcWriteTest(void)
{
    rtc_dateTime_t dt;
    dt.year = 0x7d3;
    dt.month = 0x03;
    dt.day = 0x01;
    dt.hour = 0x02;
    dt.minute = 0x03;
    dt.second = 0x04;
    dt.weekday = 0x05;
    // curr_time_val.fraction_256;
    // curr_time_val.adjust_reason;
    int8_t ret = rtc_set_datetime(&dt);
    printf("RETSET = %d\r\n",ret);
}

void rtcTest(void)
{
  i2cGpioConfiguration();
  hal_rtc_time_init();
  rtcWriteTest();
  rtc_dateTime_t dt;
  int8_t ret = rtc_get_datetime(&dt);
  if (0 == ret) {
      printf("%d-%02d-%02d %02d:%02d:%02d (W%d)", \
                  dt.year, dt.month, dt.day, \
                  dt.hour, dt.minute, dt.second, \
                  dt.weekday
                  );
  }
}
#endif // rtc


#if 0
// 光电模块
#include "driver/adc.h"
// // #include "esp_adc_cal.h"
#include "esp_adc/adc_oneshot.h"
#include "esp_adc/adc_continuous.h"
void lightMonitor(void)
{
    adc1_config_width(ADC_WIDTH_BIT_12);
    // adc2_config_width(ADC_WIDTH_BIT_12);
    adc2_config_channel_atten(ADC2_CHANNEL_2, ADC_ATTEN_DB_11);
    adc1_config_channel_atten(ADC1_CHANNEL_2, ADC_ATTEN_DB_11);
    int adc_value = adc1_get_raw(ADC1_CHANNEL_2);
    printf("adc1 = %d\r\n",adc_value);
    uint16_t v;
    adc2_get_raw(ADC2_CHANNEL_2,ADC_WIDTH_BIT_12,&v);
    printf("adc2 = %d\r\n",v);
}
#endif

void app_main(void)
{
      // beepInit();
      // beepContorl(20,2000);
      pca9557Init();
      gpio_init();
      LCD_Init();

      LCD_Clear(GREEN);

      vTaskDelay(3000 / portTICK_PERIOD_MS);
      luomuInit();
      intMx1508s();
      printfTest(testData,96);
      closePrintPower();// 使用后关闭打印电源，并不是打印机全部的电源

      deintMx1508s();

      LCD_Clear(GREEN);
      luomuInit();
      intMx1508s();
      printfTest(testData1,30);
      closePrintPower();

      deintMx1508s();


      while(1) {
            LCD_Clear(RED);
            vTaskDelay(100 / portTICK_PERIOD_MS);
            // // printf("Turning on the LED\n");
            LCD_Clear(GREEN);
            // beepContorl(20,2000);
            vTaskDelay(100 / portTICK_PERIOD_MS);
            LCD_Clear(WHITE);
            // beepContorl(0,2000);
            vTaskDelay(1000 / portTICK_PERIOD_MS);
            while(1) {
            // printf("hello word = %d\r\n",i++);
            vTaskDelay(1000 / portTICK_PERIOD_MS);

            }
 }
}


/* 0.96 寸屏幕
#define LCD_NOP			0x00	//空命令
#define LCD_SWRESET		0x01	//软件复位，在睡眠和显示模式下，重置软件后需等待120ms后方可执行下一条指令
#define LCD_RDDID		0x04	//读取LCD的制造商ID（8位）、驱动版本ID（最高位为1，7位）、驱动程序ID（8位）
#define LCD_RDDST		0x09	//读取显示屏所有状态参数
#define LCD_RDDPM		0x0A	//读取显示屏能量模式
#define LCD_RDDMADCTL	0x0B	//读取显示屏MADCTL
#define LCD_RDDCOLMOD	0x0C	//读取显示屏像素定义
#define LCD_RDDIM		0x0D	//读取显示屏图片模式
#define LCD_RDDSM		0x0E	//读取显示屏单信号模式
#define LCD_RDDSDR		0x0F	//读取显示屏自我诊断结果
#define LCD_SLPIN		0x10	//进入最小功耗模式
#define LCD_SLPOUT 		0x11	//关闭睡眠模式
#define LCD_PTLON		0x12	//打开Partial模式
#define LCD_NORON		0x13	//恢复到正常模式
#define LCD_INVOFF		0x20	//显示反转模式中恢复
#define LCD_INVON		0x21	//进入反向显示模式
#define LCD_GAMSET		0x26	//当前显示选择所需的伽马曲线
#define LCD_DISPOFF		0x28	//关闭显示，帧内存的输出被禁用
#define LCD_DISPON		0x29	//开启显示，帧内存的输出被启用
#define LCD_CASET		0x2A	//列地址设置，每个值代表帧内存中的一列
#define LCD_RASET		0x2B	//行地址设置，每个值代表帧内存中的一列
#define LCD_RAMWR		0x2C	//写入内存
#define LCD_RGBSET		0x2D	//颜色模式设置
#define LCD_RAMRD		0x2E	//读取内存
#define LCD_PTLAR		0x30	//部分模式的显示区域设置
#define LCD_SCRLAR		0x33	//定义垂直滚动区域的显示
#define LCD_TEOFF		0x34	//关闭(Active Low) TE信号线的撕裂效应输出信号
#define LCD_TEON		0x35	//打开TE信号线的撕裂效果输出信号
#define LCD_MADCTL		0x36	//定义帧内存的读写扫描方向
#define LCD_VSCSAD		0x37	//设置垂直滚动起始地址，此命令与垂直滚动定义(33h)一起使用
#define LCD_IDMOFF		0x38	//关闭空闲模式
#define LCD_IDMON		0x39	//开启空闲模式
#define LCD_COLMOD		0x3A	//定义通过MCU接口传输的RGB图片数据的格式
#define LCD_FRMCTR1		0xB1	//设置全色正常模式的帧频
#define LCD_FRMCTR2 	0xB2	//设置空闲模式的帧频
#define LCD_FRMCTR3 	0xB3	//设置部分模式/全色的帧频率
#define LCD_INVCRT 		0xB4	//反转模式控制
#define LCD_PWCTR1 		0xC0	//设置AVDD、MODE、VRHP、VRHN
#define LCD_PWCTR2 		0xC1	//设置VGH与VGL的供电功率
#define LCD_PWCTR3 		0xC2	//设置正常模式/全色模式下的运放的电流
#define LCD_PWCTR4 		0xC3	//设置空闲模式/八色模式下的运放的电流
#define LCD_PWCTR5 		0xC4	//设置部分模式/全色模式下的运放的电流
#define LCD_VMCTR1 		0xC5	//设置VCOM电压电平以减少闪烁问题
#define LCD_VMOFCTR		0xC7	//VCOM偏移控制，在使用命令0xC7之前，命令0xD9的位VMF_EN必须启用(设置为1)
#define LCD_WRID2		0xD1	//写入LCD模块版本的7位数据，保存到NVM
#define LCD_WRID3		0xD2	//写入项目代码模块的8位数据，保存到NVM
#define LCD_NVFCTR1		0xD9	//NVM状态控制
#define LCD_RDID1		0xDA	//读字节返回8位LCD模块的制造商ID
#define LCD_RDID2		0xDB	//读字节返回8位LCD模块/驱动程序版本ID
#define LCD_RDID3		0xDC	//读字节返回8位LCD模块/驱动ID
#define LCD_NVFCTR2		0xDE	//NVM读取命令
#define LCD_NVFCTR3		0xDF	//NVM写取命令
#define LCD_GMCTRP1		0xE0	//Gamma ‘+’ Polarity Correction Characteristics Setting
#define LCD_GMCTRN1		0xE1	//Gamma ‘+’ Polarity Correction Characteristics Setting
#define LCD_GCV			0xFC	//自动调节门泵时钟，节省功耗
*/
